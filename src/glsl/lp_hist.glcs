#version 450

#extension GL_NV_gpu_shader5 : enable
#extension GL_NV_shader_atomic_int64 : enable
#extension GL_NV_shader_atomic_float : enable

layout(local_size_x = 128) in;

layout(rgba8ui, binding = 0) uniform readonly coherent uimage3D src_tex;

struct data_type {
	uint64_t rg;
	uint64_t ba;
};

layout(std430, binding = 0) buffer plot_buffer {
	data_type rgba[];
} plot;

uniform int num_data_values;
uniform ivec2 resolution;
uniform float threshold;

struct relation {
	ivec2 indices;
	vec4 line_a;
	vec4 line_b;
};

uniform relation relations[6];




struct tf_primitive {
	int type;
	vec4 cntrd;
	vec4 color;
	vec4 width;
};

uniform tf_primitive mdtf[8];
uniform int num_mdtf_primitives;

// return an alpha value equivalent to the value of a gaussian function at the given centroid position with the specified with
float evaluate_gauss_primitive(vec4 density, vec4 gaussian_centroid, vec4 gaussian_width) {

	// construct a matrix with diagonal components set to the given value
	mat4 K;
	K[0] = vec4(2.0 / gaussian_width[0], 0.0, 0.0, 0.0);
	K[1] = vec4(0.0, 2.0 / gaussian_width[1], 0.0, 0.0);
	K[2] = vec4(0.0, 0.0, 2.0 / gaussian_width[2], 0.0);
	K[3] = vec4(0.0, 0.0, 0.0, 2.0 / gaussian_width[3]);
	
	vec4 diff = density - gaussian_centroid;
	mat4 K2 = K*K;

	// calculate exponent; use dot product to multiply two vectors with the intention of receiving a single floating point result
	float exponent = dot(diff, K2*diff);

	return exp(-exponent);
}

// return an alpha value of 1 or 0 based on if the input values are inside a hyperbox
float evaluate_box_primitive(vec4 density, vec4 centroid_positions, vec4 width) {
	vec4 a_delta = abs(density - centroid_positions);
	bvec4 inside = lessThanEqual(a_delta, 0.5*width);
	return all(inside) ? 1.0 : 0.0;
}

// return an alpha value of 1 or 0 based on if the input values are inside a hyperellipsoid
float evaluate_sphere_primitive(vec4 density, vec4 centroid_positions, vec4 width) {
	const vec4 delta = density - centroid_positions;

	const float max_width = max(max(max(width[0], width[1]), width[2]), width[3]);
	const vec4 lambda = 2.0 * vec4(max_width) / width;

	vec4 scaled_diff = delta * lambda;
	scaled_diff *= scaled_diff;

	const float dist = sqrt(scaled_diff[0] + scaled_diff[1] + scaled_diff[2] + scaled_diff[3]) - max_width;

	return dist > 0.0 ? 0.0 : 1.0;
}

// evaluate the multi dimensional transfer function for a given n-dimensional input vector
vec4 evaluate_transfer_function(vec4 density, float alpha_scale) {
	
	vec3 color_sum = vec3(0.0);
	float alpha_sum = 0.0;
	
	for (int i = 0; i < num_mdtf_primitives; i++) {
		tf_primitive tfp = mdtf[i];
		float alpha = 0.0;

		// Calculate the alpha value based on the primitive type
		switch(tfp.type) {
		case 0:
			alpha = evaluate_gauss_primitive(density, tfp.cntrd, tfp.width);
			break;
		case 1:
			alpha = evaluate_box_primitive(density, tfp.cntrd, tfp.width);
			break;
		case 2:
			alpha = evaluate_sphere_primitive(density, tfp.cntrd, tfp.width);
			break;
		}

		// Apply global opacity and primitive color alpha
		alpha *= tfp.color.a * alpha_scale;

		// Add for every primitive
		color_sum += alpha * tfp.color.rgb;
		alpha_sum += alpha;
	}

	color_sum = clamp(color_sum, 0.0, 1.0);
	return vec4(color_sum, 1.0);
}







/*
// 4x uint
#define PLOT_POINT(BUF, I, J, COL) \
	int BUF##_idx = plot_coords[I] + plot_size * plot_coords[J]; \
	atomicAdd(BUF.rgba[BUF##_idx][0], COL.r); \
	atomicAdd(BUF.rgba[BUF##_idx][1], COL.g); \
	atomicAdd(BUF.rgba[BUF##_idx][2], COL.b); \
	atomicAdd(BUF.rgba[BUF##_idx][3], COL.a);
*/

/*
// 4x float
#define PLOT_POINT(BUF, I, J, COL) \
	int BUF##_idx = plot_coords[I] + plot_size * plot_coords[J]; \
	atomicAdd(BUF.rgba[BUF##_idx][0], COL.r); \
	atomicAdd(BUF.rgba[BUF##_idx][1], COL.g); \
	atomicAdd(BUF.rgba[BUF##_idx][2], COL.b); \
	atomicAdd(BUF.rgba[BUF##_idx][3], COL.a);
*/
 
// 2x uint64_t
#define PLOT_POINT(BUF, I, J, PCOL_RG, PCOL_BA) \
	int BUF##_idx = plot_coords[I] + plot_size * plot_coords[J]; \
	atomicAdd(BUF.rgba[BUF##_idx].rg, PCOL_RG); \
	atomicAdd(BUF.rgba[BUF##_idx].ba, PCOL_BA);

void plot_pixel(in ivec2 p, uint64_t pc_rg, uint64_t pc_ba) {
	int idx = p.x + resolution.x * p.y;
	atomicAdd(plot.rgba[idx].rg, pc_rg);
	atomicAdd(plot.rgba[idx].ba, pc_ba);
}

void bresenham(int x0, int y0, int x1, int y1, uint64_t pc_rg, uint64_t pc_ba) {
    int dx =  abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
    int dy = -abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
    int err = dx + dy, e2;
    
    while(true) {
        plot_pixel(ivec2(x0, y0), pc_rg, pc_ba);
        if(x0 == x1 && y0 == y1)
			break;
        e2 = 2 * err;
        if(e2 > dy) { err += dy; x0 += sx; }
        if(e2 < dx) { err += dx; y0 += sy; }
    }
}

void plot_line(in vec4 p, in relation rel, uint64_t pc_rg, uint64_t pc_ba) {
	vec4 l = rel.line_a;
	vec4 r = rel.line_b;

	ivec2 s = ivec2(mix(l.xy, l.zw, 0.8*p[rel.indices.x]) + 0.1);
	ivec2 e = ivec2(mix(r.xy, r.zw, 0.8*p[rel.indices.y]) + 0.1);

	bresenham(s.x, s.y, e.x, e.y, pc_rg, pc_ba);
}

void main() {
	int idx = int(gl_GlobalInvocationID.x);

	if(idx < num_data_values) {
		ivec3 src_size = imageSize(src_tex);
		ivec3 src_coord;

		src_coord.x = idx % src_size.x;
		src_coord.y = (idx / src_size.x) % src_size.y;
		src_coord.z = idx / (src_size.x * src_size.y);

		vec4 p = vec4(imageLoad(src_tex, src_coord)) / 255.0;

		float avg = p[0] + p[1] + p[2] + p[3];
		avg *= 0.25f;

		if (avg > threshold) {
			vec4 color = evaluate_transfer_function(p, 1.0);
			uvec2 c8_rg = uvec2(color.rg * 128);
			uvec2 c8_ba = uvec2(color.ba * 128);

			uint64_t packed_color_rg = packUint2x32(c8_rg);
			uint64_t packed_color_ba = packUint2x32(c8_ba);

			plot_line(p, relations[0], packed_color_rg, packed_color_ba);
			plot_line(p, relations[1], packed_color_rg, packed_color_ba);
			plot_line(p, relations[2], packed_color_rg, packed_color_ba);
			plot_line(p, relations[3], packed_color_rg, packed_color_ba);
			plot_line(p, relations[4], packed_color_rg, packed_color_ba);
			plot_line(p, relations[5], packed_color_rg, packed_color_ba);

			/*relation rel = relations[0];
			vec4 l = rel.line_a;
			vec4 r = rel.line_b;

			ivec2 s = ivec2(mix(l.xy, l.zw, 0.8*p[rel.indices.x]) + 0.1);
			ivec2 e = ivec2(mix(r.xy, r.zw, 0.8*p[rel.indices.y]) + 0.1);

			//plot_pixel(ivec2(s.x, s.y), packed_color_rg, packed_color_ba);
			//plot_pixel(ivec2(e.x, e.y), packed_color_rg, packed_color_ba);

			bresenham(s.x, s.y, e.x, e.y, packed_color_rg, packed_color_ba);*/
		}








		/*if (avg > threshold) {
			ivec2 plot_coords = clamp(ivec2(p.xy * resolution), ivec2(0), resolution - 1);

			vec4 color = vec4(1.0, 0.0, 0.0, 1.0);//evaluate_transfer_function(p, 1.0);
			uvec2 c8_rg = uvec2(color.rg * 128);
			uvec2 c8_ba = uvec2(color.ba * 128);

			uint64_t packed_color_rg = packUint2x32(c8_rg);
			uint64_t packed_color_ba = packUint2x32(c8_ba);

			int plot_idx = plot_coords.x + resolution.x * plot_coords.y;
			atomicAdd(plot.rgba[plot_idx].rg, packed_color_rg);
			atomicAdd(plot.rgba[plot_idx].ba, packed_color_ba);

			//PLOT_POINT(sp0, 0, 1, packed_color_rg, packed_color_ba);
			//PLOT_POINT(sp1, 0, 2, packed_color_rg, packed_color_ba);
			//PLOT_POINT(sp2, 0, 3, packed_color_rg, packed_color_ba);
			//PLOT_POINT(sp3, 3, 1, packed_color_rg, packed_color_ba);
			//PLOT_POINT(sp4, 3, 2, packed_color_rg, packed_color_ba);
			//PLOT_POINT(sp5, 2, 1, packed_color_rg, packed_color_ba);
		}*/
	}
}
