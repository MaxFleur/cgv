#version 430

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

layout(binding = 0, rgba8ui) uniform readonly uimage3D volume_tex;
layout(binding = 1, rgba32f) uniform writeonly image3D gradient_tex;

vec4 get_value(ivec3 resolution, ivec3 idx) {
	
	idx = clamp(idx, ivec3(0), resolution - 1);
	return vec4(imageLoad(volume_tex, idx)) / 255.0;
}

vec3 gradient_sobel(ivec3 resolution, ivec3 idx) {

	mat3x4 grad = mat3x4(0.0);

	vec4 val[8];

	val[0] = get_value(resolution, idx + ivec3(-1, -1, -1));
	val[1] = get_value(resolution, idx + ivec3(-1, -1, +1));
	val[2] = get_value(resolution, idx + ivec3(-1, +1, -1));
	val[3] = get_value(resolution, idx + ivec3(-1, +1, +1));

	val[4] = get_value(resolution, idx + ivec3(+1, -1, -1));
	val[5] = get_value(resolution, idx + ivec3(+1, -1, +1));
	val[6] = get_value(resolution, idx + ivec3(+1, +1, -1));
	val[7] = get_value(resolution, idx + ivec3(+1, +1, +1));

	grad[0] += -1.0 * val[0];
	grad[0] += -1.0 * val[1];
	grad[0] += -1.0 * val[2];
	grad[0] += -1.0 * val[3];

	grad[0] += +1.0 * val[4];
	grad[0] += +1.0 * val[5];
	grad[0] += +1.0 * val[6];
	grad[0] += +1.0 * val[7];

	grad[1] += -1.0 * val[0];
	grad[1] += -1.0 * val[1];
	grad[1] += -1.0 * val[4];
	grad[1] += -1.0 * val[5];

	grad[1] += +1.0 * val[2];
	grad[1] += +1.0 * val[3];
	grad[1] += +1.0 * val[6];
	grad[1] += +1.0 * val[7];

	grad[2] += -1.0 * val[0];
	grad[2] += -1.0 * val[2];
	grad[2] += -1.0 * val[4];
	grad[2] += -1.0 * val[6];

	grad[2] += +1.0 * val[1];
	grad[2] += +1.0 * val[3];
	grad[2] += +1.0 * val[5];
	grad[2] += +1.0 * val[7];

	val[0] = get_value(resolution, idx + ivec3(-1, +0, -1));
	val[1] = get_value(resolution, idx + ivec3(-1, +0, +1));
	val[2] = get_value(resolution, idx + ivec3(-1, -1, +0));
	val[3] = get_value(resolution, idx + ivec3(-1, +1, +0));

	val[4] = get_value(resolution, idx + ivec3(+1, +0, -1));
	val[5] = get_value(resolution, idx + ivec3(+1, +0, +1));
	val[6] = get_value(resolution, idx + ivec3(+1, -1, +0));
	val[7] = get_value(resolution, idx + ivec3(+1, +1, +0));

	grad[0] += -3.0 * val[0];
	grad[0] += -3.0 * val[1];
	grad[0] += -3.0 * val[2];
	grad[0] += -3.0 * val[3];

	grad[0] += +3.0 * val[4];
	grad[0] += +3.0 * val[5];
	grad[0] += +3.0 * val[6];
	grad[0] += +3.0 * val[7];
	
	grad[1] += -3.0 * val[2];
	grad[1] += -3.0 * val[6];

	grad[1] += +3.0 * val[3];
	grad[1] += +3.0 * val[7];
	
	grad[2] += -3.0 * val[0];
	grad[2] += -3.0 * val[4];

	grad[2] += +3.0 * val[1];
	grad[2] += +3.0 * val[5];

	val[0] = get_value(resolution, idx + ivec3(+0, -1, -1));
	val[1] = get_value(resolution, idx + ivec3(+0, -1, +1));
	val[2] = get_value(resolution, idx + ivec3(+0, +1, -1));
	val[3] = get_value(resolution, idx + ivec3(+0, +1, +1));

	val[4] = get_value(resolution, idx + ivec3(-1, +0, +0));
	val[5] = get_value(resolution, idx + ivec3(+1, +0, +0));
	val[6] = get_value(resolution, idx + ivec3(+0, -1, +0));
	val[7] = get_value(resolution, idx + ivec3(+0, +1, +0));

	grad[1] += -3.0 * val[0];
	grad[1] += -3.0 * val[1];
	
	grad[1] += +3.0 * val[2];
	grad[1] += +3.0 * val[3];
	
	grad[2] += -3.0 * val[0];
	grad[2] += -3.0 * val[2];
	
	grad[2] += +3.0 * val[1];
	grad[2] += +3.0 * val[3];

	val[0] = get_value(resolution, idx + ivec3(+0, +0, -1));
	val[1] = get_value(resolution, idx + ivec3(+0, +0, +1));

	grad[0] += -6.0 * val[4];
	grad[0] += +6.0 * val[5];

	grad[1] += -6.0 * val[6];
	grad[1] += +6.0 * val[7];

	grad[2] += -6.0 * val[0];
	grad[2] += +6.0 * val[1];

	const float norm = 1.0/44.0;

	grad[0] *= norm;
	grad[1] *= norm;
	grad[2] *= norm;

	vec3 avg_grad = vec3(grad[0].x, grad[1].x, grad[2].x);
	avg_grad += vec3(grad[0].y, grad[1].y, grad[2].y);
	avg_grad += vec3(grad[0].z, grad[1].z, grad[2].z);
	avg_grad += vec3(grad[0].w, grad[1].w, grad[2].w);

	return 0.25 * avg_grad;
	//return avg_grad;
}

void main() {

    // the voxel coordinates of this thread
    ivec3 idx = ivec3(gl_GlobalInvocationID);
	ivec3 resolution = imageSize(volume_tex);

	if(idx.x < resolution.x && idx.y < resolution.y && idx.z < resolution.z) {
		// compute gradient using the sobel operator
		//imageStore(gradient_tex, idx, -1.0 * vec4(gradient_sobel(idx), 0.0));
		imageStore(gradient_tex, idx, vec4(gradient_sobel(resolution, idx), 0.0));
	}
}
